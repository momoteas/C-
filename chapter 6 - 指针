6.1 内存和地址：
    。地址与内容：名字和内存位置之间的关联并不是硬件所提供的，它是由编译器为我们实现的。硬件仍然通过地址访问内存位置；
    
6.2 值和类型：
    。变量包含了一系列内容为0和1的位。它们可以被解释为整数，也可以被解释为浮点数，这取决于它们被使用的方式。不能简单地通过检查一个值的位来判断它的类型；
    
6.3 指针变量的内容：
    。指针的初始化是用&操作符完成的，它用于产生操作数的内存地址；

6.4 间接访问操作符：
    。通过一个指针访问它所指向的地址的过程称为间接访问（indirection）或解引用指针（dereferencing the pointer）。这个用于执行间接访问的操作符是
    单目操作符*；

6.5 未初始化和非法的指针：
    。例如：  int *a;
             ...
             *a=12;
             
6.6 NULL指针：
    。标准定义了NULL指针，它作为一个特殊的指针变量，表示不指向任何东西。要使用一个指针变量作为NULL，你可以给它赋一个零值；
    。NULL指针的概念是非常有用的，因为它给你一种方法，表示某个特定的指针目前并未指向任何东西；
    。对一个NULL指针进行解应用操作是非法的；
    
6.7 指针、间接访问和左值：
    
6.8 指针、间接访问和变量：
    。*&a=25
    
6.9 指针常量：
    
6.10 指针的指针：
    。指针变量和其他变量一样，占据内存中某个特定的位置，所以用&操作符取得它的地址是合法的；
    。声明：int **c
    。例如：    int a=12;
              int *b=&a;
              int **c=&b;
              *操作符具有从右向左的结合性，所以这个表达式相当于*（*c)。*c访问c所指向的位值，我们知道是变量b。第2个间接访问操作符访问这个位置所指向
              的地址，也就是变量a.
              
6.11 指针表达式：
    。       char ch = 'a';
            char *cp = &ch;
    。&ch：作为左值是非法的，因为当表达式&ch进行求值时，它的结果应该存储于计算机的什么地方呢？它肯定会位于某个地方，但你无法知道它位于何处。这个表达式
    并未标识任何机器内存的特定位置，所以它不是一个合法的左值；
    。&cp：同&ch类似，作为左值它也是非法的...；
    。*cp+1:作为左值它是非法的，因为表达式的最终结果的存储位置并未清晰定义；
    。*(cp+1):作为左值是合法的，它的左值是位置本身。
    。++，--作为左值一样是非法的，这个表达式所访问的是ch后面的那个内存位置，我们如何知道原先存储于那个地方的是什么东西呢？一    般而言，我们无法得知，
    所以，像这样的表达式是非法的；
    
6.13 指针运算：
    。6.13.1 算术运算：仅限于+，-两种形式；
        。第二种类型的指针运算如下形式：指针 - 指针
    。6.13.2 关系运算：<, <=, >, >=
    
6.15 警告与总结：
    。错误地对一个未初始化的指针变量进行解引用；
    。错误地对一个NULL指针进行解引用；
    。向函数错误地传递NULL指针；
    。未检测到指针表达式的错误，从而导致不可预料的后果；
    。对一个指针进行减法运算，使它非法地指向了数组第1个元素的前面的内存位置；









